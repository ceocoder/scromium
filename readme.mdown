Scromium
==========

The way shit is supposed to work:

    val cassandra = Cassandra.start
    
    cassandra.keyspace("fuck") { ks =>
      implicit val consistency = ReadConsistency.One
      
      //get uses the % operator to denote a supercolumn when chaining paths together
      //this is to give the scala compiler the hint that the return type is going to be a
      //supercolumn when we execute with just the supercolumn type
      val column = ks.get("row", "column_family") % "supercolumn" / "column" ! ReadConsistency.Quorum
      val supercolumn = ks.get("row", "column_family") % "supercolumn" !
      val column = ks.get("row", "cf") / "c" !
      
      //query a column path via a supercolumn using a keyrange (requires OPP)
      val query = ks.rangeSuper("super_column_family", "supercolumn")
      //or use a path to a regular column family
      val query = ks.range("column_family")
      //or a path to a supercolumn family
      val query = ks.rangeSuper("super_column_family")
      
      //we can then set the key range
      query.keys("from_key", "to_key", limit=100)
      
      //then we can set the columns explicitly like this
      query.columns("column1", "column2", "column3")
      //or as a range
      query.columns("start", "end" limit=100)
      //and then execute the query
      query ! ReadConsistency.Quorum
      
      //multiget_slice queries
      val query = ks.multiget("cf", "supercolumn")
      
      query.keys("row1"...)
      // we can set the columns explicitly like this
      query.columns("column1", "column2", "column3")
      // or as a range
      query.columns("start", "end" limit=100)
      // execute the query
      query ! ReadConsistency.Quorum
      
      //inserts use the arrow notation for columnfamily and supercolumn paths
      ks.insert[T]("row", "column_family" -> "supercolumn" -> "column", value)
      ks.insert("row", "column_family" -> "column", value, timestamp, WriteConsistency.One)
      
      //batches can be built up a little at a time before being executed
      val batch = ks.batch
      
      batch -> "row" { row =>
        row.add("cf" -> "sc" -> "c", value)
      }
      
      batch!
      
      val batch = ks.batch("row")
      batch.add("cf" -> "supercolumn" -> "column", value, timestamp)
      batch ! WriteConsistency.One
      
    }
